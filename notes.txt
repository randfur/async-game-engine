- Architecture
  - 2022-07-24
    - Game
      - Not subclassed.
      - Has IO modules shared across every game.
        - Drawing.
        - Input events.
        - Sound.
      - Has active scene and background scene.
      - Ticks the active and background scenes.
      - Has inactive scenes that don't receive ticks.
      - May need onActivate/onDeactivate scene events.
    - Scenes
      - Has subclasses for presets.
      - Basic subclass
        - Has components
          - 2D drawing
          - 2D collisions
          - Sprites
      - Own and runs jobs.
      - Base scene may need input and audio componets?
    - Components
      - Not a class, just a convention (though maybe that should change).
      - Jobs register with the components to receive events.
      - Registration includes automatic clean up to deregister when the job stops.
    - Job
      - Async function invoked with access to special sleep methods that can be paused or stopped by the parent scene/jobs.
      - Stores clean up work to run once stopped like a destructor.
    - Entity
      - Subclass of Job.
      - Invoked differently, more suited to OOP.
      - Has subclasses for presets.
        - Basic subclass
          - Registers with BasicScene's 2D drawing.
          - Registers with BasicScene's collisions.
          - Registers with BasicScene's sprite component.

- Typescript
  - Use as API reference documentation.
  - Validate that JS matches TS declarations using typescript-service-worker.
    - Can you have .d.ts files parallel to JS files to run type checking?
  - Just using TS as comments for now.

- Testing
  - Have testing framework that can collate multiple test files, run and summarize all the tests.

- Documentation
  - Use .d.ts files for API references.
  - Have README explain in English how things are meant to work.
  - Have example code for common idioms.

- Presets
  - Preset Scene and Entity subclasses.
  - Modules initialised as members, possibly hooked up to each other.
  - Helper methods that use the modules.
  - BasicScene and BasicEntity.
    - 2D game stuff.
    - 2D drawing.
    - Camera transformed drawing.
    - 2D collision.
    - Sprites.
    - In game scene & sprite editor.
  - Basic3DScene and Basic3DEntity.
    - 3D game stuff.
    - 3D drawing.
    - 3D collision.
    - 3D meshes?
    - Sprite billboards.
  - Game itself is not subclassed, contains the core IO and scene swapping logic used by all game types.

- Collision
  - Need to be able to query collisions at "imaginary" positions rather than only receive events for collisions at current location.
    - Add and remove a temporary collider?
      - Not sure how expensive adding and removing is, hopefully O(ln) ish.

- Scenes
  - Initial states of entities.
  - Tile map.
  - Size?
    - Affects camera panning?
  - Entities paused when not in an active scene?
    - Some entities not in any scene and are always active?
      - Controllers of the game.
    - Needs core game integration to mess with nextFrame()?
    - Needs drawing/collision module integration to cease having effects on other scene entities?
      - Scene association needs to be part of core game engine & entity?
        - Pass a scene to Game constructor instead of async run()?
        - Job has associated scene.
        - Game has active scene.
        - Modules with registered jobs filter processing to only those associated with active scene.
          - Sounds expensive.
          - Need to optimise out non-active jobs.
          - Map of scene -> job?
        - Maybe scenes contain drawing and collision modules?
          - Maybe what is Game today is actually Scene.
          - Drawing and input will be two-level.
            - Game level to set up the resources (canvas, event listeners).
            - Scene level to handle scene scoped registrations.
        - Scenes are job registration scopes.
          - Jobs are registered with a particular scene for execution (nextFrame() and sleep()) and modules like collision, input and drawing.
          - Job takes (job, scene, game)?
        - Game has map from scene class -> scene instance.
  - Entities can move between scenes e.g. player?
  - Declarative ways to transition between scenes?
    - Scenes connected as a big graph?
      - Scene transition graph editor?
  - Stack of scenes?
    - Copy Android Activity stack model?
  - Singleton, cannot be instantiated multiple times.

- In game editing
  - Access to project directory, can directly edit game files and assets.
  - Scene editor.
    - Needs scene file format.
      - List of entities.
      - Entity construction arguments.
        - BasicEntity can have standard arguments for initial state.
          - Collision.
          - Sprite.
          - Transform.
      - Tile set + tile map.
      - Tile map can have layers with optional parallax effect.
  - Sprite editor.
    - Needs sprite file format.
  - Entity editor?
    - Output JS files?
    - What if JS files get edited by hand?
    - Can store declarative components in a particular getter?
      - Make it easier for the editor to find and update.
      - initialState() or something.

- Sprites
  - Resource loading
  - Sprite library
  - Connection with drawing module.
  - Connection with collision module.
  - Has 3D version for 3D drawing and 3D collisions?

- Pool

- Input

- 3D Context
  - Types of 3D drawing primitives.
  - Pools of draw objects.
  - Z sort before draw.

- Old ideas
  - Modules
    - `game.modules.collision`?
    - Pass modules to Game constructor?
    - Modules have init() where they can receive Game?
    - Pass module constructors to Game constructor?
      - Can build dependency system around this?
    - Pass module constructor to `module()` getter?
      - Automatic dependency management, no need for explicit dependencies or initialisation.
      - No way to configure the modules at a global scene.
        - Game constructor can still receive some module instances and deduce their constructor.
    - Entity module getter?
      - this.module(Collision)
      - this.mod(Collision)
      - this.get(Collision)
      - Basic entity can add helper getters.
        - this.collision
    - Getting modules by module constructor may be slow?
    - Other possible modules
      - 3D Context
      - 3D Collision
      - Resource loader? Maybe core.
      - Score system.
      - Input events.
    - Why have modules live on Game instead of global singletons?
      - Globals feel bad.
        - Implicit dependencies blown open.
      - Game is a non-global object, would be weird for everything else to not follow suit.
    - Alternative: No modules and all these modules are part of the core.
