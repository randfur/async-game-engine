- Make ideas
  - Flying through landscape of 3D squares.
  - Hanging vines in 3D.
  - Shmup.
  - Chain reactions.

- Experiments
  - A space to try out new tech (like file system access) and ideas without altering the core engine.
  - Camera object integration with drawing.
  - Collision interactions.

- Roadmap
  - 2022-08-01
    - End goal
      - Animated sprite format + editor.
      - Camera control.
      - In game sprite editor.
      - In game level editor.
      - In game debugging.
      - Useful input events.
      - Audio?
      - Number generation utilities.
    - Stepping stone goals
      - Basic input example.
      - Click drag input events example.
      - Emoji sprite example.
      - Convex collision test.
      - Large level with camera following example.
      - Multi level teleportation example.
      - Mini sprite editor test.
      - In RAM level editor test.
      - Save to disk test.

- Inputs
  - Architecture
    - Could unify all inputs into the same event.
      - Easy to delegate.
    - Could split up by input types like HTML.
      - Probably better performance.
  - BasicEntity can check if subclass has overridden the input event handler.
    - Don't register with input component if subclass doesn't care.
      - This would probably make up for the performance concerns of a single event.

- Architecture
  - 2022-07-24
    - Game
      - Not subclassed.
      - Has IO modules shared across every game.
        - Drawing.
        - Input events.
        - Sound.
      - Has active scene and background scene.
      - Ticks the active and background scenes.
      - Has inactive scenes that don't receive ticks.
      - May need onActivate/onDeactivate scene events.
    - Scenes
      - Has subclasses for presets.
      - Basic subclass
        - Has components
          - 2D drawing
          - 2D collisions
          - Sprites
      - Own and runs jobs.
      - Base scene may need input and audio componets?
    - Components
      - Not a class, just a convention (though maybe that should change).
      - Jobs register with the components to receive events.
      - Registration includes automatic clean up to deregister when the job stops.
    - Job
      - Async function invoked with access to special sleep methods that can be paused or stopped by the parent scene/jobs.
      - Stores clean up work to run once stopped like a destructor.
    - Entity
      - Subclass of Job.
      - Invoked differently, more suited to OOP.
      - Has subclasses for presets.
        - Basic subclass
          - Registers with BasicScene's 2D drawing.
          - Registers with BasicScene's collisions.
          - Registers with BasicScene's sprite component.

- Typescript
  - Use as API reference documentation.
  - Validate that JS matches TS declarations using typescript-service-worker.
    - Can you have .d.ts files parallel to JS files to run type checking?
  - Just using TS as comments for now.

- Testing
  - Have testing framework that can collate multiple test files, run and summarize all the tests.

- Documentation
  - Use .d.ts files for API references.
  - Have README explain in English how things are meant to work.
  - Have example code for common idioms.

- Presets
  - Preset Scene and Entity subclasses.
  - Modules initialised as members, possibly hooked up to each other.
  - Helper methods that use the modules.
  - BasicScene and BasicEntity.
    - 2D game stuff.
    - 2D drawing.
      - Camera transformed drawing.
      - HTMLCanvas2DContext wrapper.
        - Apply canvas transforms.
        - Use own transform stack.
          - save() and restore() performance is bad.
        - Drawing method overloads that work with Vec2.
    - 2D collision.
    - Sprites.
    - In game scene & sprite editor.
    - Not sure how to go about a basic entity's shape.
      - Sprites have shapes.
      - Colliders have shapes.
      - Entities have position?
      - Sprites and collider shapes could be set as offset to the entity's position.
        - Maybe later have transform instead of position to generalise to different scales and rotations.
        - Maybe even later let entities have a parent entity which their transform lives nested inside.
          - Used by platformers, the character's transform becomes a child node of a moving platform's transform to make moving along with it trivial.
      - Colliders don't have shapes?
        - Colliders use the sprite's shape if there is a sprite otherwise a fallback width/height shape on entitiy?
  - Basic3DScene and Basic3DEntity.
    - 3D game stuff.
    - 3D drawing.
    - 3D collision.
    - 3D meshes?
    - Sprite billboards.
  - Game itself is not subclassed, contains the core IO and scene swapping logic used by all game types.

- Collision
  - Need to be able to query collisions at "imaginary" positions rather than only receive events for collisions at current location.
    - Add and remove a temporary collider?
      - Not sure how expensive adding and removing is, hopefully O(ln) ish.

- Scenes
  - Initial states of entities.
  - Tile map.
  - Size?
    - Affects camera panning?
  - Entities paused when not in an active scene?
    - Some entities not in any scene and are always active?
      - Controllers of the game.
    - Needs core game integration to mess with nextFrame()?
    - Needs drawing/collision module integration to cease having effects on other scene entities?
      - Scene association needs to be part of core game engine & entity?
        - Pass a scene to Game constructor instead of async run()?
        - Job has associated scene.
        - Game has active scene.
        - Modules with registered jobs filter processing to only those associated with active scene.
          - Sounds expensive.
          - Need to optimise out non-active jobs.
          - Map of scene -> job?
        - Maybe scenes contain drawing and collision modules?
          - Maybe what is Game today is actually Scene.
          - Drawing and input will be two-level.
            - Game level to set up the resources (canvas, event listeners).
            - Scene level to handle scene scoped registrations.
        - Scenes are job registration scopes.
          - Jobs are registered with a particular scene for execution (nextFrame() and sleep()) and modules like collision, input and drawing.
          - Job takes (job, scene, game)?
        - Game has map from scene class -> scene instance.
  - Entities can move between scenes e.g. player?
  - Declarative ways to transition between scenes?
    - Scenes connected as a big graph?
      - Scene transition graph editor?
  - Stack of scenes?
    - Copy Android Activity stack model?
  - Singleton, cannot be instantiated multiple times.

- In game editing
  - Access to project directory, can directly edit game files and assets.
  - Scene editor.
    - Needs scene file format.
      - List of entities.
      - Entity construction arguments.
        - BasicEntity can have standard arguments for initial state.
          - Collision.
          - Sprite.
          - Transform.
      - Tile set + tile map.
      - Tile map can have layers with optional parallax effect.
  - Sprite editor.
    - Needs sprite file format.
  - Entity editor?
    - Output JS files?
    - What if JS files get edited by hand?
    - Can store declarative components in a particular getter?
      - Make it easier for the editor to find and update.
      - initialState() or something.
  - Opening the editors
    - Special hot key?
    - Can be disabled as a global game option (maybe later).
    - Implemented as a separate scene?
      - A sub scene?
      - May need input/drawing layering controls.

- Global game options
  - Part of game args.
  - Stashed on game, specific classes read the values relevant to them.
  - Very duck typey unfortunately.
  - Not sure how to dynamically build an args interface based on stuff used in the code.
  - Some kind of type  registration system.

- Sprites
  - Resource loading
  - Sprite library
  - Connection with drawing module.
  - Connection with collision module.
  - Has 3D version for 3D drawing and 3D collisions?

- Pool

- Input
  - Hot keys
    - Entities register keys relevant to them?
    - Entities specify priority layering and bubbling rules?
    - Key to action mapping should be very declarative to allow easy remapping and introspection.
  - State
    - Key and button states exposed outside of events.
    - Arrow keys direction exposed as Vec2.
    - Mouse click drag path and time exposed.

- JobSlots
  - Used to store jobs by name.
  - Will automatically stop() jobs when they're overridden.
  - Maybe can support job factories to make starting them from multiple places easier.
  - Maybe proxy object over an object?
    - Nah, too confusing, use a Map style interface with get() and set().

- 3D Context
  - Types of 3D drawing primitives.
  - Pools of draw objects.
  - Z sort before draw.

- Old ideas
  - Modules
    - `game.modules.collision`?
    - Pass modules to Game constructor?
    - Modules have init() where they can receive Game?
    - Pass module constructors to Game constructor?
      - Can build dependency system around this?
    - Pass module constructor to `module()` getter?
      - Automatic dependency management, no need for explicit dependencies or initialisation.
      - No way to configure the modules at a global scene.
        - Game constructor can still receive some module instances and deduce their constructor.
    - Entity module getter?
      - this.module(Collision)
      - this.mod(Collision)
      - this.get(Collision)
      - Basic entity can add helper getters.
        - this.collision
    - Getting modules by module constructor may be slow?
    - Other possible modules
      - 3D Context
      - 3D Collision
      - Resource loader? Maybe core.
      - Score system.
      - Input events.
    - Why have modules live on Game instead of global singletons?
      - Globals feel bad.
        - Implicit dependencies blown open.
      - Game is a non-global object, would be weird for everything else to not follow suit.
    - Alternative: No modules and all these modules are part of the core.
